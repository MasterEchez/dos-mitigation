# Setup
- import_playbook: "setup.yml"

- hosts: server, router, sink, active_clients, active_attackers
  tasks:
    - name: create local log directories
      file:
        path: "{{ user_dir }}/logs/{{ session }}/{{ timestamp }}/{{ inventory_hostname }}"
        state: directory
      delegate_to: localhost
- hosts: localhost
  tasks:
    - name: copy settings
      copy:
        src: "{{ user_dir }}/.settings"
        dest: "{{ user_dir }}/logs/{{ session }}/{{ timestamp }}/.settings"

# Unmitigated Baseline
- import_playbook: "clear_logs.yml"
- import_playbook: "mitigations/{{ mitigation }}_disable.yml"

- hosts: localhost
  gather_facts: no
  tasks:
    - name: Set synchronized start time (exp_delay seconds in the future)
      set_fact:
        sync_start_time: "{{ lookup('pipe', 'date -u -d \"+' ~ exp_delay ~ ' seconds\" +%Y-%m-%dT%H:%M:%S.%3NZ') }}"

- hosts: active_clients
  gather_facts: no
  vars:
    total_async_time: "{{ window_length | int * 3 + post_attack_delay | int + exp_delay | int }}"
  tasks:
    - name: Start Jitsi clients with sync timestamp
      shell: |
        . ~/.nvm/nvm.sh
        node puppeteer/join-and-log.js {{ inventory_hostname }} ./fourpeople.y4m {{ window_length }} "{{ sync_start_time }}" 0
      async: "{{ total_async_time }}"
      poll: 0
      register: client_async
      args:
        executable: /bin/bash

    - name: Wait for client logging to finish
      pause:
        seconds: "{{ window_length | int * 3 + post_attack_delay | int }}"

    - name: Check on clients
      async_status:
        jid: "{{ client_async.ansible_job_id }}"
      register: result
      until: result.finished
      retries: 10
      delay: 3
      failed_when: result.rc != 0

    - name: Async cleanup
      async_status:
        jid: "{{ client_async.ansible_job_id }}"
        mode: cleanup

- hosts: server
  gather_facts: no
  tasks:
  - name: restart jitsi
    shell: "{{ user_dir }}/common/jitsi/restarter.sh"
  become: yes

- hosts: server, router, sink, active_clients, active_attackers
  gather_facts: no
  tasks:
  - name: wait for logging to finish
    pause:
      seconds: "{{ cleanup_delay }}"
  - name: compress logs
    archive:
      path: /tmp/logs
      dest: /tmp/logs.zip
      format: zip
    ignore_errors: yes
  - name: collect logs
    fetch:
      src: /tmp/logs.zip
      dest: "{{ user_dir }}/logs/{{ session }}/{{ timestamp }}/{{ inventory_hostname }}/UB/logs.zip"
      flat: yes
    ignore_errors: yes

# Unmitigated Attack
- import_playbook: "clear_logs.yml"

- hosts: active_attackers
  gather_facts: no
  tasks:
  - name: get server IP
    shell: "getent hosts {{ server_name }} | awk '{ print $1 }'"
    register: server_ip
  - name: get local IP
    shell: "getent hosts {{ inventory_hostname }} | awk '{ print $1 }'"
    register: local_ip

- hosts: active_clients
  gather_facts: no
  tasks:
  - name: start jitsi clients
    shell: |
      . ~/.nvm/nvm.sh
      node puppeteer/join-and-log.js {{ inventory_hostname }} ./fourpeople.y4m {{ window_length }} "$(date -u -d '+{{ exp_delay }} seconds')" 0
    async: "{{ window_length | int * 3 + exp_delay | int + post_attack_delay | int }}"
    poll: 0
    register: client_async
    args:
      executable: /bin/bash
  - name: wait for client logging to start
    pause:
      seconds: "{{ exp_delay }}"
  - name: wait for first window
    pause:
      seconds: "{{ window_length }}"

- hosts: active_attackers
  gather_facts: no
  tasks:
  - name: launch {{ attack_type }} attack at {{ server_name }}
    shell: timeout {{ window_length }} cpulimit -l {{ attacker_cpu_limit }} -f -- {{ user_dir }}/common/attacks/{{ attack_type }} {{ server_ip.stdout }} {{ attacker_busywait }} {{ local_ip.stdout }}
    async: "{{ window_length }}"
    poll: 0
    become: yes
    register: attacker_async
  - name: wait for second window
    pause:
      seconds: "{{ window_length }}"
  - name: check on attackers
    async_status:
      jid: "{{ attacker_async.ansible_job_id }}"
    register: result
    until: result.finished
    failed_when: result.rc not in [0, 124]
    become: yes
  - name: async cleanup
    async_status:
      jid: "{{ attacker_async.ansible_job_id }}"
      mode: cleanup
    become: yes
  - name: wait for third window
    pause:
      seconds: "{{ window_length }}"

- hosts: active_clients
  gather_facts: no
  tasks:
  - name: wait for logging to be finished
    pause:
      seconds: "{{ post_attack_delay }}"
  - name: check on clients
    async_status:
      jid: "{{ client_async.ansible_job_id }}"
    register: result
    until: result.finished
    failed_when: result.rc != 0
  - name: async cleanup
    async_status:
      jid: "{{ client_async.ansible_job_id }}"
      mode: cleanup

- hosts: server
  gather_facts: no
  tasks:
  - name: restart jitsi
    shell: "{{ user_dir }}/common/jitsi/restarter.sh"
  become: yes

- hosts: server, router, sink, active_clients, active_attackers
  gather_facts: no
  tasks:
  - name: wait for logging to finish
    pause:
      seconds: "{{ cleanup_delay }}"
  - name: compress logs
    archive:
      path: /tmp/logs
      dest: /tmp/logs.zip
      format: zip
    ignore_errors: yes
  - name: collect logs
    fetch:
      src: /tmp/logs.zip
      dest: "{{ user_dir }}/logs/{{ session }}/{{ timestamp }}/{{ inventory_hostname }}/UA/logs.zip"
      flat: yes
    ignore_errors: yes

# Mitigated Baseline
- import_playbook: "clear_logs.yml"
- import_playbook: "mitigations/{{ mitigation }}_enable.yml"

- hosts: localhost
  gather_facts: no
  tasks:
    - name: Set synchronized start time (exp_delay seconds in the future)
      set_fact:
        sync_start_time: "{{ lookup('pipe', 'date -u -d \"+' ~ exp_delay ~ ' seconds\" +%Y-%m-%dT%H:%M:%S.%3NZ') }}"

- hosts: active_clients
  gather_facts: no
  vars:
    total_async_time: "{{ window_length | int * 3 + post_attack_delay | int + exp_delay | int }}"
  tasks:
    - name: Start Jitsi clients with sync timestamp
      shell: |
        . ~/.nvm/nvm.sh
        node puppeteer/join-and-log.js {{ inventory_hostname }} ./fourpeople.y4m {{ window_length }} "{{ sync_start_time }}" 0
      async: "{{ total_async_time }}"
      poll: 0
      register: client_async
      args:
        executable: /bin/bash

    - name: Wait for client logging to finish
      pause:
        seconds: "{{ window_length | int * 3 + post_attack_delay | int }}"

    - name: Check on clients
      async_status:
        jid: "{{ client_async.ansible_job_id }}"
      register: result
      until: result.finished
      retries: 10
      delay: 3
      failed_when: result.rc != 0

    - name: Async cleanup
      async_status:
        jid: "{{ client_async.ansible_job_id }}"
        mode: cleanup

- hosts: server
  gather_facts: no
  tasks:
  - name: restart jitsi
    shell: "{{ user_dir }}/common/jitsi/restarter.sh"
  become: yes

- hosts: server, router, sink, active_clients, active_attackers
  gather_facts: no
  tasks:
  - name: wait for logging to finish
    pause:
      seconds: "{{ cleanup_delay }}"
  - name: compress logs
    archive:
      path: /tmp/logs
      dest: /tmp/logs.zip
      format: zip
    ignore_errors: yes
  - name: collect logs
    fetch:
      src: /tmp/logs.zip
      dest: "{{ user_dir }}/logs/{{ session }}/{{ timestamp }}/{{ inventory_hostname }}/MB/"
      flat: yes
    ignore_errors: yes

# Mitigated Attack
- import_playbook: "clear_logs.yml"
- hosts: active_attackers
  gather_facts: no
  tasks:
  - name: get server IP
    shell: "getent hosts {{ server_name }} | awk '{ print $1 }'"
    register: server_ip
  - name: get local IP
    shell: "getent hosts {{ inventory_hostname }} | awk '{ print $1 }'"
    register: local_ip

- hosts: active_clients
  gather_facts: no
  tasks:
  - name: start jitsi clients
    shell: |
      . ~/.nvm/nvm.sh
      node puppeteer/join-and-log.js {{ inventory_hostname }} ./fourpeople.y4m {{ window_length }} "$(date -u -d '+{{ exp_delay }} seconds')" 0
    async: "{{ window_length | int * 3 + exp_delay | int + post_attack_delay | int }}"
    poll: 0
    register: client_async
    args:
      executable: /bin/bash
  - name: wait for client logging to start
    pause:
      seconds: "{{ exp_delay }}"
  - name: wait for first window
    pause:
      seconds: "{{ window_length }}"

- hosts: active_attackers
  gather_facts: no
  tasks:
  - name: launch {{ attack_type }} attack at {{ server_name }}
    shell: timeout {{ window_length }} cpulimit -l {{ attacker_cpu_limit }} -f -- {{ user_dir }}/common/attacks/{{ attack_type }} {{ server_ip.stdout }} {{ attacker_busywait }} {{ local_ip.stdout }}
    async: "{{ window_length }}"
    poll: 0
    become: yes
    register: attacker_async
  - name: wait for second window
    pause:
      seconds: "{{ window_length }}"
  - name: check on attackers
    async_status:
      jid: "{{ attacker_async.ansible_job_id }}"
    register: result
    until: result.finished
    failed_when: result.rc not in [0, 124]
    become: yes
  - name: async cleanup
    async_status:
      jid: "{{ attacker_async.ansible_job_id }}"
      mode: cleanup
    become: yes
  - name: wait for third window
    pause:
      seconds: "{{ window_length }}"

- hosts: active_clients
  gather_facts: no
  tasks:
  - name: wait for logging to be finished
    pause:
      seconds: "{{ post_attack_delay }}"
  - name: check on clients
    async_status:
      jid: "{{ client_async.ansible_job_id }}"
    register: result
    until: result.finished
    failed_when: result.rc != 0
  - name: async cleanup
    async_status:
      jid: "{{ client_async.ansible_job_id }}"
      mode: cleanup

- hosts: server
  gather_facts: no
  tasks:
  - name: restart jitsi
    shell: "{{ user_dir }}/common/jitsi/restarter.sh"
  become: yes

- hosts: server, router, sink, active_clients, active_attackers
  gather_facts: no
  tasks:
  - name: wait for logging to finish
    pause:
      seconds: "{{ cleanup_delay }}"
  - name: compress logs
    archive:
      path: /tmp/logs
      dest: /tmp/logs.zip
      format: zip
    ignore_errors: yes
  - name: collect logs
    fetch:
      src: /tmp/logs.zip
      dest: "{{ user_dir }}/logs/{{ session }}/{{ timestamp }}/{{ inventory_hostname }}/MA/"
      flat: yes
    ignore_errors: yes

- import_playbook: "mitigations/{{ mitigation }}_disable.yml"

- hosts: server, router, sink, active_clients, active_attackers
  gather_facts: yes
  vars:
    - log_dir: "{{ user_dir }}/logs/{{ session }}/{{ timestamp }}/{{ inventory_hostname }}"
  tasks:
    - name: decompress logs
      unarchive:
        src: "{{ log_dir }}/{{ item }}/logs.zip"
        dest: "{{ log_dir }}/{{ item }}/"
      loop:
        - "UB"
        - "UA"
        - "MB"
        - "MA"
      delegate_to: localhost
      ignore_errors: yes
    - name: delete zip files
      file:
        path: "{{ log_dir }}/{{ item }}/logs.zip"
        state: absent
      loop:
        - "UB"
        - "UA"
        - "MB"
        - "MA"
      become: yes
      delegate_to: localhost
    # - name: copy fact files
    #   copy:
    #     src: /tmp/ansible_facts/{{ inventory_hostname }}
    #     dest: "{{ log_dir }}/.facts.json"
    #   delegate_to: localhost
